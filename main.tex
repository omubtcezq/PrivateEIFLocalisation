% autosam.tex
% Annotated sample file for the preparation of LaTeX files
% for the final versions of papers submitted to or accepted for 
% publication in AUTOMATICA.

% See also the Information for Authors.

% Make sure that the zip file that you send contains all the 
% files, including the files for the figures and the bib file.

% Output produced with the elsart style file does not imitate the
% AUTOMATICA style. The style file is generic for all Elsevier
% journals and the output is laid out for easy copy editing. The
% final document is produced from the source file in the
% AUTOMATICA style at Elsevier.

% You may use the style file autart.cls to obtain a two-column 
% document (see below) that more or less imitates the printed 
% Automatica style. This may helpful to improve the formatting 
% of the equations, tables and figures, and also serves to check 
% whether the paper satisfies the length requirements.

% Please note: Authors must not create their own macros.

% For further information regarding the preparation of LaTeX files 
% for Elsevier, please refer to the "Full Instructions to Authors" 
% from Elsevier's anonymous ftp server on ftp.elsevier.nl in the
% directory pub/styles, or from the internet (CTAN sites) on
% ftp.shsu.edu, ftp.dante.de and ftp.tex.ac.uk in the directory
% tex-archive/macros/latex/contrib/supported/elsevier.


% The use of LaTeX2e is preferred.
%\documentclass{elsart}

% Enable this line and disable the 
% preceding line to obtain a two-column 
% document whose style resembles the
% printed Automatica style.
\documentclass[twocolumn]{autart}


% Include this line if your 
% document contains figures,
\usepackage{graphicx}
% or this line, depending on which
% you prefer.
%\usepackage[dvips]{epsfig}

% User imported packages
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz}


\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\begin{document}

\begin{frontmatter}
% Running title for regular 
% papers but only if the title  
% is over 5 words. Running title 
% is not shown in output.
%\runtitle{Insert a suggested running title}

% Title, preferably not more than 10 words.
\title{Localisation and Sensor Privacy Using the Extended Information Filter and Secure Weighted Aggregation\thanksref{footnoteinfo}}

\thanks[footnoteinfo]{This paper was not presented at any IFAC 
meeting. Corresponding author Uwe~D.~Hanebeck. Tel. +49--721--608--43909.}

% Add the 
% e-mail address 
% (ead) as shown
\author[ISAS]{Marko Ristic}\ead{marko.ristic@kit.edu},
\author[ISAS]{Benjamin Noack}\ead{noack@kit.edu},
\author[ISAS]{Uwe D. Hanebeck}\ead{uwe.hanebeck@kit.edu}

% Please supply
\address[ISAS]{Intelligent Sensor-Actuator-Systems Laboratory, Institute for Anthropomatics, Karlsruhe Institute of Technology, 76131 Karlsruhe, Germany}

% Five to ten keywords,  
% chosen from the IFAC 
% keyword list or with the 
% help of the Automatica 
% keyword wizard
\begin{keyword}
System state estimation; Data privacy; Sensor fusion; Kalman filters.
\end{keyword}

% Abstract of not more than 200 words.
\begin{abstract}
Distributed state estimation and localisation methods have become increasingly popular with the rise of ubiquitous computing, and have led naturally to an increased concern regarding data and estimation privacy. Traditional distributed sensor navigation methods involve the leakage of sensor information or navigator location during localisation protocols and fail to preserve participantsâ€™ data privacy. Existing approaches which provide such guarantees, fail to address sensor and navigator privacy in some common model-based non-linear measurement localisation methods forfeiting broad applicability. We define a cryptographically secure weighted aggregation scheme which we apply to the Extended Kalman Filter with range-sensor measurements, and show that navigator location, sensor locations and sensor measurements can remain private during navigation. The security requirements, leakage, and cryptographic proof are given for the private filter and weighted aggregation scheme, and simulations of the filter are used to evaluate the accuracy and performance of the method. Our approach defines a novel, computationally plausible and cryptographically private, model-based localisation filter with direct application to environments where nodes may not be fully trusted and data is considered sensitive.
\end{abstract}

\end{frontmatter}

\section{Introduction}


--

Introduce localisation, filtering and the need for privacy. 

Examples of environments where privacy is relevant and concrete examples where lack of privacy could have large costs

Methods for introducing security and privacy include differential privacy methods and encryption methods. 

Differential privacy involves using statistical noise as security to make individual users' information cannot be deduced. Often requires a trusted aggregator, although secure aggregation methods exist. always requires noising result such that the outcome is not exact (a problem in localisation).

Encryption schemes involve formal indistinguishability proofs typically over bits or integers. They rely on computationally hard problems involving security parameters of a sufficiently large size; therefore the additional computational requirements of using encryption schemes should be pointed out and what this means in a real-time distributed sensor system. Continuing, explain public-key cryptography applicability to distributed systems; difference to symmetric schemes. Homomorphic encryption power and use case. Why FHE isn't used often, why additive partially homomorphic encryption is.

Advancements in function providing encryption schemes such as homomorphic encryption have also led to several other types of schemes which have found uses in signal processing. Private aggregation schemes allow the secure computation of the sum of encrypted values originating from different parties, leaking only the final result. When considering such multi-party encryption protocols, formal security definitions must now also incorporate the added dangers of colluding malicious parties, and lead to new notions of security. For example Aggregator Obliviousness (AO) is typically proven for private aggregation schemes, while alternatives such as Private Weighted Secure Aggregator Obliviousness (pWSAO) exist for other specific use-cases.

Another example of function providing encryption, and a generalisation of private aggregation, is called functional encryption (FE) and its distributed extension, multi-client functional encryption (MCFE), which allow the unencrypted result of an arbitrary function to be computed from encrypted inputs. General FE and MCFE are known to be quite computationally expensive (from meeting with ITI and student Johannes - need ref.) but alternatives providing only a subset of possibly computable function exist; for example, inner product encryption.

Several of the aforementioned encryption schemes have found uses in secure localisation, estimation, and control.

\subsection{Relevant Literature on Encrypted Localisation and Estimation}

Model-free localisation using homomorphic encryption examples include polygon thing, WSN examples which protect against adversaries but in the case of the WSN paper. don't preserve anchor privacy. Importantly, model-based filtering and localisation provide more accurate estimates and these are not applicable there.

Model-based estimation examples include Aristov paper (which requires a linear model, and a hierarchy of sensors), Farokhi paper (which requires the controller compute entirely in encrypted space and send input back to actuator - supporting only the cloud-as-a-service type architectures) and Alexandru paper (which implements a distributed control environment but requires a constant gain matrix K)

pWSAO achieved in Alexandru weighted aggregation, but requires redistributing keys at every timestep resulting in a costly operation, and a complicated communication protocol.

In addition to applying suitable encryption schemes to signal processing tasks, care must be taken when converting sensor output into an encryptable homomorphic format. As is the case with our proposed localisation method, real number sensor output does not trivially encode to integers such that the homomorphic properties provided by an additive encryption scheme over integers keep the underlying real numbers consistent. Methods for handling the encoding of real numbers such that they can be used in homomorphic encryption exist. Google bignum adds power but risks overflow and leaks exponents, Farokhi leaks no information but allows only a single multiplication (extendable to more but each further multiplication limits the real number size and increases the risk of overflow).

Briefly describe navigator scenario and our contributions

Section Summary
%In Section \ref{sec:private_localisation} we will show how this scheme can be used to compute the measurement covariance and measurement vector homomorphically at each sensor, and allow the navigator to update their 

\subsection{Notation}
Notation


\section{Problem Statement} \label{sec:problem_statement}

Restate the scenario but more formally. Give a concrete example - plane and signal towers.

Exact security guarantees we aim for, as well as the definitions for these guarantees (pWSAO and indistinguishability but in context of localisation as well). Note that learning only the sum in aggregation (as is normal in AO) would, in this case, tell the navigator the average location and measurements of all sensors, which is fine as it does not disclose any exact sensor.

Passive attacks only from sensors to learn navigator position (Otherwise one could do some kind of attack that would send a fake measurement and note the change in its own measurements - possible this would give away the average of other sensors' measurements but unclear). Any largely incorrect inputs from sensors may also be detectable by comparison to alternative navigator onboard sensors (GPS etc.). Justify by saying sensors need to behave for localisation to work in the first place.

Active attacks from navigator to find sensor location allowed, but assume that weights sent to all sensors are the same. In a wireless setting, all sensors would receive all broadcast weights anyway. While special hardware, which may support directional broadcasting or receiving, could be used to locate sensors individually this is beyond the scope of what is considered in our problem.

Point out that learning the aggregation of sensor outputs, which contains measurement and location information also means that the average location and measurement of the sensors may be leaked, and is accepted as a part of the leakage as it is inferrable from the aggregation scheme and any functioning model-based localisation where measurements are not known

Rough computational capabilities expected by parties

Fixed sensor subsets of which only whole subsets can be used at once. Maybe a picture of what this might look like in a high level distributed localisation diagram. Should consider that this sub-grouping would also mean the leakage of the average sensor/measurement of each subset not all sensors at once. This should be considered when choosing sensor subsets and locations.


%  .d8888b.                            888                 8888888b.                  888 d8b
% d88P  Y88b                           888                 888   Y88b                 888 Y8P
% 888    888                           888                 888    888                 888
% 888        888d888 888  888 88888b.  888888 .d88b.       888   d88P 888d888 .d88b.  888 888 88888b.d88b.
% 888        888P"   888  888 888 "88b 888   d88""88b      8888888P"  888P"  d8P  Y8b 888 888 888 "888 "88b
% 888    888 888     888  888 888  888 888   888  888      888        888    88888888 888 888 888  888  888
% Y88b  d88P 888     Y88b 888 888 d88P Y88b. Y88..88P      888        888    Y8b.     888 888 888  888  888
%  "Y8888P"  888      "Y88888 88888P"   "Y888 "Y88P"       888        888     "Y8888  888 888 888  888  888
%                         888 888
%                    Y8b d88P 888
%                     "Y88P"  888
\section{Cryptography Preliminaries}
When defining our system security requirements and encryption scheme, we will reference some existing cryptographic security notions, the additively homomorphic Paillier encryption scheme, and the Joye-Libert private aggregation scheme.

% Quickly define homomorphic encryption and private aggregation here??

\subsection{Security Notions}
The security of a cryptographic scheme is typically defined by a security \textit{game}, which captures both the desired privacy guarantees, as well as the capabilities of attackers \cite{katzIntroductionModernCryptography2008}. The typical security notion for a homomorphic encryption scheme is Indistinguishability under Chosen Plaintext Attack (IND-CPA) \cite{}. 
\begin{definition}
An encryption scheme meets IND-CPA security if an attacker who can choose plaintext messages to be encrypted at will, gains no additional information about an unknown plaintext message when they learn only its encryption. 

The formal security game for IND-CPA has been given in Appendix \ref{app:ind_cpa}.
\end{definition}
Private aggregation schemes aim for the security notion of Aggregator Obliviousness (AO) \cite{}. 
\begin{definition}
An encryption scheme meets AO security if no colluding subset of participants \textit{excluding} the aggregator gains additional information about the remaining aggregation values given only their encryptions, while any colluding subset \textit{including} the aggregator learns only their sum. 

The formal security game for AO has been given in Appendix \ref{app:ao}.
\end{definition}

\subsection{Paillier Encryption Scheme}
The Paillier encryption scheme \cite{paillierPublicKeyCryptosystemsBased1999} is an additively homomorphic encryption scheme which bases its security on the decisional composite residuosity assumption (DCRA) and meets the security notion of IND-CPA. Key generation of the Paillier scheme is performed by choosing two sufficiently large primes $p$ and $q$, and computing $N=pq$. A generator $g$ is also required for encryption, which is often set to $g=N+1$ when $p$ and $q$ are of equal bit length \cite{}. The public key is defined by $(N, g)$ and secret key by $(p, q)$.

Encryption of a plaintext message $m \in \mathbb{Z}_N$, producing ciphertext $c \in \mathbb{Z}^{*}_{N^2}$, is computed by
\begin{equation}
    c = g^m r^N \pmod{N^2}
\end{equation}
for a randomly chosen $r \in \mathbb{Z}_{N}$. $r^N$ can be considered the noise term which hides the value $g^m \pmod{N^2}$, which due to the scheme construction, is an easily computable discrete logarithm. The decryption of a ciphertext is computed by
\begin{equation}
    m = \frac{L(c^\lambda\pmod{N^2})}{L(g^\lambda\pmod{N^2})} \pmod{N}
\end{equation}
where $\lambda = \mathsf{lcm}(p-1, q-1)$ and $L(u) = \frac{u-1}{N}$.

In addition to encryption and decryption, the following homomorphic functions are provided by the Paillier scheme. $\forall m_1,m_2 \in \mathbb{Z}_N$,
\begin{align}
    \mathcal{D}(\mathcal{E}(m_1)\mathcal{E}(m_2)\!\pmod{N^2}) &= m_1+m_2\!\pmod{N} \\
    \mathcal{D}(\mathcal{E}(m_1)g^{m_2}\!\pmod{N^2}) &= m_1+m_2\!\pmod{N} \\
    \mathcal{D}(\mathcal{E}(m_1)^{m_2}\!\pmod{N^2}) &= m_1m_2\!\pmod{N}\,.
\end{align}

\subsection{Joye-Libert Private Aggregation Scheme}
The Joye-Libert private aggregation scheme \cite{joyeScalableSchemePrivacyPreserving2013} is a scheme defined on time-series data and meets the security notion of AO. Similarly to the Paillier scheme, it bases its security on the DCRA. A notable difference to a public-key encryption scheme is the need for a trusted party to perform an initial key generation and distribution step.

Key generation is computed by choosing two equal length and sufficiently large primes $p$ and $q$, and computing $N=pq$. Additionally, hash function $H:\mathbb{Z} \rightarrow \mathbb{Z}_{N^2}$ is defined, and the public key is set to $(N, H)$. $n$ private keys are generated by choosing $sk_i,\,1\leq i\leq n$ uniformly from $\mathbb{Z}_{N^2}$ and distributing them to all users, while the last key is set as
\begin{equation}
    sk_0 = -\sum^{n}_{i=1}sk_i \pmod{N^2}\,,
\end{equation}
and sent to the aggregator.

Encryption of plaintext $m^{(t)}_{i} \in \mathbb{Z}_N$ to ciphertext $c^{(t)}_{i} \in \mathbb{Z}_{N^2}$ at time $t$ is computed by user $i$ as
\begin{equation}
    c^{(t)}_{i} = (N+1)^{m^{(t)}_{i}} H(t)^{sk_i} \pmod{N^2}\,,
\end{equation}
where the $H(t)^{sk_i}$ can be considered the noise term which hides the again easily computable discrete logarithm $g^{m^{(t)}_{i}} \pmod{N^2}$, where $g=N+1$.

When all encryptions $c^{(t)}_{i},\,1\leq i \leq n$ are sent to the aggregator, private summation and decryption are computed by the functions
\begin{equation}
    c^{(t)} = H(t)^{sk_0}\prod^{n}_{i=1}c^{(t)}_{i} \pmod{N^2}
\end{equation}
and
\begin{equation}
    \sum^{n}_{i=1}m^{(t)}_{i} = \frac{c^{(t)}-1}{N}\,. \label{eqn:agg_decryption}
\end{equation}
Correctness follows from $\sum^{n}_{i=0}sk_i = 0$, and thus
\begin{equation*}
    \begin{split}
        &H(t)^{sk_0}\prod^{n}_{i=1}c_{i,t} \pmod{N^2} \\
        \equiv &H(t)^{sk_0}\prod^{n}_{i=1}(N+1)^{m_{i,t}} H(t)^{sk_i} \pmod{N^2} \\
        \equiv &H(t)^{\sum^n_{j=0}sk_j} \prod^{n}_{i=1}g^{m_{i,t}} \pmod{N^2} \\
        \equiv &(N+1)^{\sum^n_{i=1}m_{i,t}} \pmod{N^2}
    \end{split}
\end{equation*}
removing all noise terms.

%  .d8888b.                            888                 8888888b.                  888
% d88P  Y88b                           888                 888   Y88b                 888
% 888    888                           888                 888    888                 888
% 888        888d888 888  888 88888b.  888888 .d88b.       888   d88P 888d888 .d88b.  88888b.
% 888        888P"   888  888 888 "88b 888   d88""88b      8888888P"  888P"  d88""88b 888 "88b
% 888    888 888     888  888 888  888 888   888  888      888        888    888  888 888  888
% Y88b  d88P 888     Y88b 888 888 d88P Y88b. Y88..88P      888        888    Y88..88P 888 d88P
%  "Y8888P"  888      "Y88888 88888P"   "Y888 "Y88P"       888        888     "Y88P"  88888P"
%                         888 888
%                    Y8b d88P 888
%                     "Y88P"  888
\section{Private Linear-Combination Aggregation}
For achieving the goal of private localisation defined in Section \ref{sec:problem_statement} we will require a multi-party protocol for computing linear combinations of weights, and their subsequent aggregation. In the context of navigation, $m$ weights $\omega_1^{(t)}, \dots , \omega_m^{(t)}$ are first broadcast by the navigator, linear combinations $y^{(t)}_i=\sum^m_{j=1}x_{j,i}^{(t)}\omega_i^{(t)}$ are computed by each sensor $1\leq i\leq n$, and aggregation is computed back at the navigator, at every time step $t$. This has been summarized in Figure \ref{fig:agg_steps}. In Section \ref{sec:private_localisation} we will show how this protocol is sufficient to compute measurement covariances and measurement vectors, and update the Extended Information Filter.

\begin{figure}[htbp]
\centering
\vspace{\baselineskip}
\begin{tikzpicture}[font=\footnotesize,scale=0.75]
    % Step 1
    \node at (5,22.5) {\small 1. Broadcast and linear combinations step};
    % Navigator
    \node at (1.25,19.25) {Navigator};
    \fill (1.25,18.25) [blue!40] ellipse (0.5 and 0.5);
    % Sensors
    \node at (7.5,21.75) {Sensor $1$};
    \fill [red!40] (5.875,19.75) rectangle (9.5,21.25);
    \node at (7.75,20.5) {$\displaystyle y_1^{(t)} = \sum^m_{j=1}x_{1,j}^{(t)}\omega_j^{(t)}$};
    \node at (7.5,14.75) {Sensor $n$};
    \fill [red!40] (5.875,15.25) rectangle (9.5,16.75);
    \node at (7.75,16) {$\displaystyle y_n^{(t)} = \sum^m_{j=1}x_{n,j}^{(t)}\omega_j^{(t)}$};
    \fill [black] (7.5,18.75) circle (0.05);
    \fill [black] (7.5,17.75) circle (0.05);
    \fill [black] (7.5,18.25) circle (0.05);
    % Lines
    \draw [-latex] plot[smooth, tension=.7] coordinates {(1.75,18.5) (5.75,20.25)};
    \draw [-latex] plot[smooth, tension=.7] coordinates {(1.75,18) (5.75,16.25)};
    \node at (3.5,20.25) {$(\omega_1^{(t)},\dots ,\omega_m^{(t)})$};
    \node at (3.5,16.25) {$(\omega_1^{(t)},\dots ,\omega_m^{(t)})$};
    
    % Step 2
    \node at (5,13.25) {\small 2. Aggregation step};
    % Navigator
    \node at (3.25,10.75) {Navigator};
    \fill [blue!40] (0.5,8.75) rectangle (5.625,10.25);
    \node at (3,9.5) {$\displaystyle \sum^{n}_{i=1}\sum^{m}_{j=1} x_{i,j}^{(t)}\omega_j^{(t)} = \sum^n_{i=1}y^{(t)}_{i}$};
    % Sensors
    \node at (8.75,12.5) {Sensor $1$};
    \fill  (8.75,7.5) [red!40] ellipse (0.5 and 0.5);
    \node at (8.75,6.5) {Sensor $n$};
    \fill  (8.75,11.5) [red!40] ellipse (0.5 and 0.5);
    \fill [black] (8.75,10) circle (0.05);
    \fill [black] (8.75,9) circle (0.05);
    \fill [black] (8.75,9.5) circle (0.05);
    % Lines
    \draw [-latex] plot[smooth, tension=.7] coordinates {(8.25,11.25) (5.75,10)};
    \draw [-latex] plot[smooth, tension=.7] coordinates {(8.25,7.75) (5.75,9)};
    \node at (6.75,11.5) {$y_1^{(t)}$};
    \node at (6.75,7.5) {$y_n^{(t)}$};
    
    % Bounding rectangles
    \draw [gray] (0,23.25) rectangle (10,14.25);
    \draw [gray] (0,14) rectangle (10,5.5);
\end{tikzpicture}
\vspace{\baselineskip}
\caption{Required linear-combination aggregation steps at time $t$}
\label{fig:agg_steps}
\end{figure}

To perform the protocol from Figure \ref{fig:agg_steps} in a secure manner, we must first describe the security properties we aim to achieve. Broadly speaking, we want a cryptographic scheme which allows a time-series of homomorphically computed linear combinations of encrypted weights, to be summed by a private aggregation scheme. That is, we do not want sensors to learn the navigator weights, while we do not want the navigator to learn individual weighted linear combinations. This can be summarised by the two informal security notions:
\begin{description}
    \item[Indistinguishable Weights] No colluding subset of sensors gains any additional knowledge about the navigator weights $\omega_j,\,1\leq j \leq m$ from receiving only their encryptions from the current and previous timesteps, and the ability to encrypt plaintexts of their choice.
    \item[Private Linear Combination Aggregation] No colluding subset \textit{excluding} the aggregator gains additional information about the remaining sensor values to be weighted $x^{(t)}_{i,j},\,0\leq j\leq m$, where sensor $i$ is not colluding, given only encryptions of their linear combinations $y_i$ from the current and previous timesteps. Any colluding subset \textit{including} the aggregator learns only the sum of all linear combinations weighted by weights of their choice, $\sum^n_{i=n}\sum^m_{j=1}x^{(t)}_{i,j}\omega^{(t)}_j$.
\end{description}

\begin{remark}
    The notion of a leakage function including parameters from the aggregator requires extra care to be taken when giving its definition. Since an attacker may compromise the aggregator, they have control over the choice of these parameters, and therefore over the leakage function. We note that in the leakage function above, $\sum^n_{i=n}\sum^m_{j=1}x^{(t)}_{i,j}\omega^{(t)}_j$, an individual sum weighted by the same weight may be learned by the colluding subset, \textit{e.g.} $\sum^m_{j=1}x^{(t)}_{1,j}$ given weights $(1,0,\dots,0)$, but that individual sensor values $x^{(t)}_{i,j}$ remain private due to the requirement that all sensors receive the same weights.
\end{remark}

From the informal definitions above, it is clear that weights encrypted by an IND-CPA secure encryption scheme are sufficient for the first requirement, while a scheme satisfying AO is not sufficient for the second. To formalise the second requirement, we define a novel encryption type ``Linear-Combination Aggregator Oblivious Encryption'' and an accompanying security game, which capture the additional weights and modified leakage of AO.

% 888      .d8888b.        d8888  .d88888b.
% 888     d88P  Y88b      d88888 d88P" "Y88b
% 888     888    888     d88P888 888     888
% 888     888           d88P 888 888     888
% 888     888          d88P  888 888     888
% 888     888    888  d88P   888 888     888
% 888     Y88b  d88P d8888888888 Y88b. .d88P
% 88888888 "Y8888P" d88P     888  "Y88888P"



\subsection{Linear-Combination Aggregator Oblivious Encryption}
We let a linear-combination aggregator oblivious encryption scheme be defined as a tuple of the four algorithms $(\mathsf{Setup}, \mathsf{Enc}, \mathsf{CombEnc}, \mathsf{AggDec})$. For the sake of readbility, we have ommited the time variable $t$ from values $\omega_j$ and $x_{i,j}$.

\begin{description}
    \item[$\mathsf{Setup}(\kappa)$] On input of security paramater $\kappa$, generate public parameters $\mathsf{pub}$, number of weights $m$, the aggregator's public and private keys $pk_0$ and $sk_0$, and the remaining user private keys $sk_i,\,1\leq i \leq n$.
    \item[$\mathsf{Enc}(pk_0, \omega)$] The aggregator and users can encrypt a weight $\omega$ with the aggregator public key $pk_0$, and obtain the encryption $\mathcal{E}_{pk_0}(\omega)$.
    \item[$\mathsf{CombEnc}(t, pk_0, sk_i, \mathcal{E}_{pk_0}(\omega_1),\dots,\mathcal{E}_{pk_0}(\omega_m), x_{i,1},\dots,x_{i,m})$] At time $t$, user $i$ computes and obtains the encrypted linear combination $y_i = \mathcal{E}_{pk_0,sk_i}(\sum^m_{j=1}x_{i,j}\omega_j)$ using its secret key $sk_i$.
    \item[$\mathsf{AggDec}(t, pk_0, sk_0, y_1,\dots,y_n)$] At time $t$, the aggregator computes the aggregation of linear combinations $\sum^{n}_{i=1}\sum^{m}_{j=1} x_{i,j}\omega_j$ using its private key $sk_0$.
\end{description}

Next, we formalise the security notion of Linear-Combination Aggregator Obliviousness (LCAO) as the following game between attacker and challenger:

\begin{description}
    \item[Setup] The challenger runs the $\mathsf{Setup}$ algorithm and gives $\mathsf{pub}$, $m$ and $pk_0$ to the attacker
    \item[Queries] The attacker can now perform encryptions or submit queries that are answered by the challenger. The three types of actions are:
    \begin{enumerate}
        \item \textit{Encryption:} The attacker chooses a weight $\omega$ and computes an encryption of $\omega$ under the aggregator's public key $pk_0$, obtaining $\mathcal{E}_{pk_0}(\omega)$.
        \item \textit{Combine Queries:} The attacker chooses a tuple $(i,t,\mathcal{E}_{pk_0}(\omega_1),\dots,\mathcal{E}_{pk_0}(\omega_m),x_{i,1},\dots,x_{i,m})$ such that for any two chosen combine query tuples $(i,t,\mathcal{E}_{pk_0}(\omega_1),\dots,\mathcal{E}_{pk_0}(\omega_m),x_{i,1},\dots,x_{i,m})$ and $(i',t',\mathcal{E}_{pk_0}(\omega_1'),\dots,\mathcal{E}_{pk_0}(\omega_m'),x_{i',1}',\dots,x_{i',m}')$ the following conditions hold:
        \begin{equation*}
            t = t' \implies \mathcal{E}_{pk_0}(\omega_j) = \mathcal{E}_{pk_0}(\omega_j'),\,1\leq j\leq m
        \end{equation*}
        and
        \begin{equation*}
            i = i' \wedge t = t' \implies x_{i,m} = x_{i',m}',\,1\leq j\leq m\,.
        \end{equation*}
        They are given back the encryption of the linear combination $\mathcal{E}_{pk_0,sk_i}(\sum^m_{j=1}x_{i,j}\omega_j)$ encrypted under both the aggregator public key $pk_0$ and the secret key $sk_i$.
        \item \textit{Compromise queries:} The attacker chooses $i$ and receives the secret key $sk_i$. The aggregator's secret key may also be compromised (when choosing $i=0$).
    \end{enumerate} 
    \item[Challenge] Next, the attacker chooses a time $t^*$, and a subset of users $U \subseteq S$ where $S$ is the complete set of users for which no combine queries for time $t^*$ and no compromise queries are made for the duration of the game. The attacker then chooses two series of tuples
    \begin{equation*}
        \langle(i,t^*,\mathcal{E}_{pk_0}(\omega_1),\dots,\mathcal{E}_{pk_0}(\omega_m),x_{i,1},\dots,x_{i,m})\,|\,i \in U\rangle
    \end{equation*}
    and
    \begin{equation*}
        \langle(i,t^*,\mathcal{E}_{pk_0}(\omega_1'),\dots,\mathcal{E}_{pk_0}(\omega_m'),x_{i,1}',\dots,x_{i,m}')\,|\, i \in U\rangle\,,
    \end{equation*}
    and gives them to the challenger. In the case that $0 \in U$ (\textit{i.e.} the aggregator is compromised) and $U = S$, it is additionally required that
    \begin{equation*}
        \sum^{n}_{i=1}\sum^{m}_{j=1} x_{i,j}\omega_j = \sum^{n}_{i=1}\sum^{m}_{j=1} x_{i,j}'\omega_j'\,.
    \end{equation*}
    The challenger then chooses a random bit $b \in \{1,0\}$ and returns encryptions 
    \begin{equation*}
        \langle\mathcal{E}_{pk_0,sk_i}(\sum^m_{j=1}x_{i,j}\omega_j)\,|\,i\in U\rangle
    \end{equation*}
    if $b=0$, or 
    \begin{equation*}
        \langle\mathcal{E}_{pk_0,sk_i}(\sum^m_{j=1}x_{i,j}'\omega_j')\,|\,i\in U\rangle
    \end{equation*}
    otherwise.
    \item[More Queries] The attacker can now perform more encryptions and submit queries, so long as the queries do not break the requirements in the Challenge stage. That is, $U \subseteq S$.
    \item[Guess] At the end, the attacker outputs a bit $b'$ and wins the game only if $b' = b$. The advantage of attacker $\mathcal{A}$ is defined as
    \begin{equation*}
        \mathsf{Adv}^{LCAO}(\mathcal{A}) \coloneqq \left\lvert \mathsf{Pr}[b'=b] - \frac{1}{2}\right\rvert\,.
    \end{equation*} 
\end{description}

\begin{definition}
    An encryption scheme meets LCAO security if no probabilistic-time adversary has more than a negligible advantage in winning the above security game.
\end{definition}

In the next section, we will give a solution to an encryption scheme meeting LCAO security, with IND-CPA secure weight encryption, and give a cryptographic proof for its security.

%  .d88888b.                                          888
% d88P" "Y88b                                         888
% 888     888                                         888
% 888     888 888  888 888d888      .d8888b   .d8888b 88888b.   .d88b.  88888b.d88b.   .d88b.
% 888     888 888  888 888P"        88K      d88P"    888 "88b d8P  Y8b 888 "888 "88b d8P  Y8b
% 888     888 888  888 888          "Y8888b. 888      888  888 88888888 888  888  888 88888888
% Y88b. .d88P Y88b 888 888               X88 Y88b.    888  888 Y8b.     888  888  888 Y8b.
%  "Y88888P"   "Y88888 888           88888P'  "Y8888P 888  888  "Y8888  888  888  888  "Y8888



\section{Our Scheme}
%Both scheme base their security on the decisional composite residuosity assumption (DCRA)
Explain it here

Enccryption: Choose random $r$ and compute
\begin{equation}
    \mathcal{E}_{pk_0}(\omega) = (N+1)^{\omega}r^N \pmod{N^2}\,,
\end{equation}
Combine encryption:
\begin{equation}
    \begin{split}
        y^{(t)}_i &= \mathcal{E}_{pk_0,sk_i}\left(\sum^{m}_{j=1}x^{(t)}_{i,j}\omega^{(t)}_j\right) \\
        &= H(t)^{sk_i}\prod^{m}_{j=1}\mathcal{E}_{pk_0}(\omega^{(t)}_j)^{x^{(t)}_{i,j}} \pmod{N^2} \\
        &= H(t)^{sk_i}\prod^{m}_{j=1}\mathcal{E}_{pk_0}(x^{(t)}_{i,j}\omega^{(t)}_j) \pmod{N^2} \\
        &= H(t)^{sk_i}\prod^{m}_{j=1}(N+1)^{x^{(t)}_{i,j}\omega^{(t)}_j}r^N \pmod{N^2} \\
        &= H(t)^{sk_i}(N+1)^{\sum^{m}_{j=1}x^{(t)}_{i,j}\omega^{(t)}_j}r^N \pmod{N^2}
    \end{split}
\end{equation}
for a random $r$ (not the same as above)

Aggregation and decryption in two steps. Aggregation:
\begin{equation}
    \begin{split}
        y^{(t)} &= \prod^n_{i=1}y^{(t)}_i \pmod{N^2} \\
        &= \prod^n_{i=1}H(t)^{sk_i}(N+1)^{\sum^{m}_{j=1}x_{i,j}\omega_j}r^N \pmod{N^2} \\
        &= H(t)^{\sum^n_{i=1}sk_i}\prod^n_{i=1}(N+1)^{\sum^{m}_{j=1}x^{(t)}_{i,j}\omega^{(t)}_j}r^N \pmod{N^2} \\
        &= (N+1)^{\sum^n_{i=1}\sum^{m}_{j=1}x^{(t)}_{i,j}\omega^{(t)}_j}r'^N \pmod{N^2}
    \end{split}
\end{equation}
for some $r' \in \mathbb{Z}_N$.

Decryption:
\begin{equation}
\sum^{n}_{i=1}\sum^{m}_{j=1}x^{(t)}_{i,j}\omega^{(t)}_j = \frac{L((y^{(t)})^\lambda\pmod{N^2})}{L((N+1)^\lambda\pmod{N^2})} \pmod{N}
\end{equation}

% \begin{algorithm}
%     \caption{Paillier Key Generation}\label{paillier_key_gen}
%     \begin{algorithmic}[1]
%         \Procedure{PaillierKeyGen}{$security\_param$}
%         \State $p,q \gets$ \Call{GeneratePrimes}{$security\_param$}
%         \State $\lambda \gets$ \Call{lcm}{p,q}
%         \State $pk \gets (n, n+1)$
%         \State $sk \gets \lambda$
%         \State \Return $(pk, sk)$
%         \EndProcedure
%     \end{algorithmic}
% \end{algorithm}

\subsection{Proof}
Give the reduction proof here for pWSAO and implicit indistinguishability of weights. Alternatively, sketch it out here and give reduction proof in the appendix.


\section{Private Localisation Preliminaries}

\subsection{Integer Encoding for Real Numbers}

\subsection{Extended Information Filter}


\section{Private Localisation with Privacy-Preserving Sensors} \label{sec:private_localisation}
Explain it in as an overview. How is the aggregation scheme used, what does this require from the measurement model, why can this be a problem for normal distance sensors?

Explain how leakage of the final aggregation sum to the navigator means leakage of the average sensor location and measurement to the navigator. This is the reason for the acceptance of this leakage, as we pointed out in the problem statement section.

\subsection{Requirements for Measurement Model}

\subsection{Localisation Measurement Modification}
Show here the weighted integrals that give mean and variance of the new noise. If wanting to show more working, do this in the appendix section, but probably not needed.

Point out here that the further away the sensor is when it makes its distance measurement (the larger the measurement) the more Gaussian the noise and the better the filter. Give flight navigation as an applicable example with typically high distances.

Additionally increased range accuracy may be possible when sensors know the process model of the navigator, allowing them to run their own filter (more accurate than only measurements but not as accurate as the navigator's estimate from multiple sensors) and use their filtered estimated distance as the scaling factor when computing the modified measurement variance.

\subsection{Expanding Aggregation for Multi-dimensional Inputs}
Give 1D example that's intuitive (with $a^2b$) and then reduce the equivalent ND case ($A^\top BA$) to a set of weighted sums.

Ensure that timestamps are concatenated with the position so that no aggregation values are blinded by the same noise.

% Maybe name the scheme? That would be in the heading here
\subsection{Algorithm}
Piece together the whole algorithm here.
Give the algorithm as pseudocode (including encoding and encryption)


\section{Results}
Decide on what kind of simulations and which plots to make. run times would be nice this time around

Time results can be captured in one graph. Y-axis is time, X-axis is the number of sensors, each line (different colour) will show how the runtime changes as sensors are increased for different Paillier bit-sizes (at least 3: 512, 1024, 2048). Every data point should be the average over some X number of simulations.

Accuracy plots will describe error due to encoding and the average distance of the sensors to the navigator. All plots will use the same ground truth and initial state and covariance estimates (this way average error at each timestep from multiple runs makes sense).

Plot 1 will plot the RMSE of the average of X runs at each encoding size. A fixed layout of 4 mediumly spaced sensor will be used, and a fixed Paillier bit size.

Plot 2 will plot the RMSE as the average distance of sensors changes. Fixed encoding and Paillier bit size. Vary between 4 layouts where 4 sensors are either very close to the centre (and ground truth, and progressively further out)

Plot 3 will accompany plot 3 and display the 4 layouts (arrow for ground truth and points for the sensors).

A well-defined example.

\section{Conclusion}
Possible future work to consider writing here:
Hardware implementations, measurement handling which preservers Gaussian noise, or non-Gaussian noise methods, ways of sending less information form the navigator to the sensors at each time step, active sensor attacker model, different state encryptions received at sensors.

%---Rest is template---


% \section{Introduction}
% Video, patres conscripti, in me omnium vestrum ora atque oculos esse 
% conversos, video vos non solunn de vestro ac rei publicae, verum 
% etiam, si id depulsum sit, de meo periculo esse sollicitos. Est mihi 
% iucunda in malis et grata in dolore vestra erga me voluntas, sed eam, 
% per deos inmortales, deponite atque obliti salutis meae de vobis ac 
% de vestris liberis cogitate. Mihi si haec condicio consulatus data 
% est, ut omnis acerbitates, onunis dolores cruciatusque perferrem, 
% feram non solum fortiter, verum etiam lubenter, dum modo meis 
% laboribus vobis populoque Romano dignitas salusque pariatur.

% \begin{figure}
% \begin{center}
% \includegraphics[height=4cm]{jcaesar.eps}    % The printed column  
% \caption{Gaius Julius Caesar, 100--44 B.C.}  % width is 8.4 cm.
% \label{fig1}                                 % Size the figures 
% \end{center}                                 % accordingly.
% \end{figure}

% % OR

% %\begin{figure}
% %\begin{center}
% %\epsfig{file=jcaesar,width=7cm}
% %\caption{Gaius Julius Caesar, 100--44 B.C.}
% %\label{fig1}
% %\end{center}
% %\end{figure}


% \subsection{A subsection}
% Marcus Tullius Cicero, 106--43 B.C. was a Roman statesman, orator, 
% and philosopher.  A major figure in the last years of the Republic, 
% he is best known for his orations against Catiline\footnote{
% This footnote should be very brief.}
% and for his mastery of Latin prose \cite{Heritage:92}. He was a 
% contemporary of Julius Caesar (Fig.~\ref{fig1}).

% \section{The argument}
% Some words might be appropriate describing equation~(\ref{e1}), if 
% we had but time and space enough.
% \begin{equation} \label{e1}
% {{\partial F}\over {\partial t}} =
% D{{\partial^2 F}\over {\partial x^2}}.
% \end{equation}
% See \cite{Abl:56}, \cite{AbTaRu:54}, \cite{Keo:58} and 
% \cite{Pow:85}.
% This equation goes far beyond the celebrated theorem ascribed to the great
% Pythagoras by his followers.
% \begin{thm}
% The square of the length of the hypotenuse of a right triangle equals the sum of the squares 
% of the lengths of the other two sides.
% \end{thm}
% \section{Epilogue}
% A word or two to conclude, and this even includes some inline 
% maths:  $R(x,t)\sim t^{-\beta}g(x/t^\alpha)\exp(-|x|/t^\alpha)$.

\begin{ack}                               % Place acknowledgements
Partially supported by the Roman Senate.  % here.
\end{ack}

\bibliographystyle{plain}        % Include this if you use bibtex 
                                 % and a bib file to produce the 
                                 % bibliography (preferred). The
                                 % correct style is generated by
                                 % Elsevier at the time of printing.
\bibliography{BibTeX/PrivateEIFLocalisation}

%\begin{thebibliography}{99}     % Otherwise use the  
                                 % thebibliography environment.
                                 % Insert the full references here.
                                 % See a recent issue of Automatica 
                                 % for the style.
%  \bibitem[Heritage, 1992]{Heritage:92}
%     (1992) {\it The American Heritage. 
%     Dictionary of the American Language.}
%     Houghton Mifflin Company.
%  \bibitem[Able, 1956]{Abl:56}
%     B.~C.~Able (1956). Nucleic acid content of macroscope. 
%     {\it Nature 2}, 7--9. 
%  \bibitem[Able {\em et al.}, 1954]{AbTaRu:54}   
%     B.~C. Able, R.~A. Tagg, and M.~Rush (1954).
%     Enzyme-catalyzed cellular transanimations.
%     In A.~F.~Round, editor, 
%     {\it Advances in Enzymology Vol. 2} (125--247). 
%     New York, Academic Press.
%  \bibitem[R.~Keohane, 1958]{Keo:58}
%     R.~Keohane (1958).
%     {\it Power and Interdependence: 
%     World Politics in Transition.}
%     Boston, Little, Brown \& Co.
%  \bibitem[Powers, 1985]{Pow:85}
%     T.~Powers (1985).
%     Is there a way out?
%     {\it Harpers, June 1985}, 35--47.

%\end{thebibliography}

% Each appendix must have a short title.
% Sections and subsections are supported
% in the appendices.
\appendix
\section{Indistinguishability under Chosen Plaintext Attack (IND-CPA)} \label{app:ind_cpa}
\section{Aggregator Obliviousness (AO)} \label{app:ao}

\end{document}